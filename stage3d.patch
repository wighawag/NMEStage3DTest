From 4f2bb43b57bfb4019c6268916f7cadd40efab7fc Mon Sep 17 00:00:00 2001
From: Wighawag <wighawag@gmail.com>
Date: Sun, 30 Dec 2012 21:38:04 +0530
Subject: [PATCH] add partial support for Stage3D API

---
 com/adobe/utils/AGALMiniAssembler.hx            |  737 +++++++++++++++++++++++
 native/display/Stage.hx                         |    6 +
 native/display/Stage3D.hx                       |   22 +
 native/display3D/Context3D.hx                   |  212 +++++++
 native/display3D/Context3DBlendFactor.hx        |   16 +
 native/display3D/Context3DClearMask.hx          |    8 +
 native/display3D/Context3DCompareMode.hx        |   14 +
 native/display3D/Context3DProgramType.hx        |    8 +
 native/display3D/Context3DTextureFormat.hx      |    9 +
 native/display3D/Context3DTriangleFace.hx       |    9 +
 native/display3D/Context3DVertexBufferFormat.hx |    9 +
 native/display3D/IndexBuffer3D.hx               |   17 +
 native/display3D/Program3D.hx                   |   24 +
 native/display3D/VertexBuffer3D.hx              |   19 +
 native/display3D/textures/Texture.hx            |   28 +
 native/events/ErrorEvent.hx                     |    5 +-
 native/events/Event.hx                          |    1 +
 nme/display/Stage3D.hx                          |    7 +
 nme/display3D/Context3D.hx                      |    7 +
 nme/display3D/Context3DBlendFactor.hx           |    6 +
 nme/display3D/Context3DClearMask.hx             |    6 +
 nme/display3D/Context3DCompareMode.hx           |    7 +
 nme/display3D/Context3DProgramType.hx           |    7 +
 nme/display3D/Context3DTextureFormat.hx         |    6 +
 nme/display3D/Context3DTriangleFace.hx          |    8 +
 nme/display3D/Context3DUtils.hx                 |   48 ++
 nme/display3D/Context3DVertexBufferFormat.hx    |    6 +
 nme/display3D/IndexBuffer3D.hx                  |    7 +
 nme/display3D/Program3D.hx                      |    7 +
 nme/display3D/VertexBuffer3D.hx                 |    7 +
 nme/display3D/textures/Texture.hx               |    7 +
 31 files changed, 1278 insertions(+), 2 deletions(-)
 create mode 100644 com/adobe/utils/AGALMiniAssembler.hx
 create mode 100644 native/display/Stage3D.hx
 create mode 100644 native/display3D/Context3D.hx
 create mode 100644 native/display3D/Context3DBlendFactor.hx
 create mode 100644 native/display3D/Context3DClearMask.hx
 create mode 100644 native/display3D/Context3DCompareMode.hx
 create mode 100644 native/display3D/Context3DProgramType.hx
 create mode 100644 native/display3D/Context3DTextureFormat.hx
 create mode 100644 native/display3D/Context3DTriangleFace.hx
 create mode 100644 native/display3D/Context3DVertexBufferFormat.hx
 create mode 100644 native/display3D/IndexBuffer3D.hx
 create mode 100644 native/display3D/Program3D.hx
 create mode 100644 native/display3D/VertexBuffer3D.hx
 create mode 100644 native/display3D/textures/Texture.hx
 create mode 100644 nme/display/Stage3D.hx
 create mode 100644 nme/display3D/Context3D.hx
 create mode 100644 nme/display3D/Context3DBlendFactor.hx
 create mode 100644 nme/display3D/Context3DClearMask.hx
 create mode 100644 nme/display3D/Context3DCompareMode.hx
 create mode 100644 nme/display3D/Context3DProgramType.hx
 create mode 100644 nme/display3D/Context3DTextureFormat.hx
 create mode 100644 nme/display3D/Context3DTriangleFace.hx
 create mode 100644 nme/display3D/Context3DUtils.hx
 create mode 100644 nme/display3D/Context3DVertexBufferFormat.hx
 create mode 100644 nme/display3D/IndexBuffer3D.hx
 create mode 100644 nme/display3D/Program3D.hx
 create mode 100644 nme/display3D/VertexBuffer3D.hx
 create mode 100644 nme/display3D/textures/Texture.hx

diff --git a/com/adobe/utils/AGALMiniAssembler.hx b/com/adobe/utils/AGALMiniAssembler.hx
new file mode 100644
index 0000000..7679ffb
--- /dev/null
+++ b/com/adobe/utils/AGALMiniAssembler.hx
@@ -0,0 +1,737 @@
+/*
+Copyright (c) 2011, Adobe Systems Incorporated
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+
+* Redistributions of source code must retain the above copyright notice,
+this list of conditions and the following disclaimer.
+
+* Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in the
+documentation and/or other materials provided with the distribution.
+
+* Neither the name of Adobe Systems Incorporated nor the names of its
+contributors may be used to endorse or promote products derived from
+this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+// FROM https://github.com/KTXSoftware/haXe-Platform-SDK/blob/master/src/com/ktxsoftware/flash/utils/AGALMiniAssembler.hx with fix on regexp for texture attribute
+package com.adobe.utils;
+
+import flash.display3D.Context3DProgramType;
+import flash.utils.ByteArray;
+import flash.utils.Endian;
+
+class AGALMiniAssembler {
+// ======================================================================
+//  Properties
+// ----------------------------------------------------------------------
+// AGAL bytes and error buffer
+	private var _agalcode : ByteArray;
+	private var _error : String;
+
+	private var debugEnabled : Bool;
+
+	private static var initialized : Bool = false;
+
+// ======================================================================
+//  Getters
+// ----------------------------------------------------------------------
+	public function error() : String       { return _error; }
+	public function agalcode() : ByteArray { return _agalcode; }
+
+// ======================================================================
+//  Constructor
+// ----------------------------------------------------------------------
+	public function new(debugging : Bool = false) : Void {
+		_agalcode = null;
+		_error = "";
+		debugEnabled = debugging;
+		if (!initialized) init();
+	}
+// ======================================================================
+//  Methods
+// ----------------------------------------------------------------------
+	public function assemble(mode : Context3DProgramType, source : String, verbose : Bool = false) : ByteArray {
+//var start:UInt = getTimer();
+
+		_agalcode = new ByteArray();
+		_error = "";
+
+		var isFrag:Bool = false;
+
+		if (mode == Context3DProgramType.FRAGMENT) isFrag = true;
+
+		_agalcode.endian = Endian.LITTLE_ENDIAN;
+		_agalcode.writeByte(0xa0);            // tag version
+		_agalcode.writeUnsignedInt(0x1);      // AGAL version, big endian, bit pattern will be 0x01000000
+		_agalcode.writeByte(0xa1);            // tag program id
+		_agalcode.writeByte(isFrag ? 1 : 0);  // vertex or fragment
+
+		var reg : EReg = ~/[\n\r]+/g;
+		var lines : Array<String> = reg.replace(source, "\n").split("\n");
+		var nest : Int = 0;
+		var nops : Int = 0;
+		var i : Int;
+		var lng : Int = lines.length;
+
+		i = 0;
+		while (i < lng && _error == "") {
+			var line : String = new String(lines[i]);
+
+// remove comments
+			var startcomment : Int = line.indexOf("//");
+			if (startcomment != -1) line = line.substr(0, startcomment);
+
+// grab options
+			reg = ~/<.*>/g;
+			var optsi:Int = -1,
+			options:String = new String(line);
+			if (reg.match(options))
+				optsi = reg.matchedPos().pos;
+
+			var opts:Array<String> = [];
+			if (optsi != -1)
+			{
+				line = line.substr(0, optsi);
+				while (optsi != -1)
+				{
+					options = options.substr(optsi);
+
+					reg = ~/([\w\.\-\+]+)/gi;
+					if(reg.match(options)){
+						opts.push(reg.matched(0));
+						var pos = reg.matchedPos();
+						optsi = pos.pos + pos.len;
+					}else{
+						optsi = -1;
+					}
+
+				}
+			}
+
+// find opcode
+			reg = ~/^\w{3}/ig;
+			reg.match(line);
+			var opCode : String = reg.matched(0);
+			var opFound : OpCode = OPMAP.get(opCode);
+
+// if debug is enabled, output the opcodes
+			if (debugEnabled) trace(opFound);
+
+			if (opFound == null) {
+				if (line.length >= 3) trace("warning: bad line " + i + ": " + lines[i]);
+				++i;
+				continue;
+			}
+
+			line = line.substr(line.indexOf(opFound.name()) + opFound.name().length);
+
+// nesting check
+			if ((opFound.flags() & OP_DEC_NEST) != 0) {
+				nest--;
+				if (nest < 0) {
+					_error = "error: conditional closes without open.";
+					break;
+				}
+			}
+			if ((opFound.flags() & OP_INC_NEST) != 0) {
+				nest++;
+				if (nest > MAX_NESTING) {
+					_error = "error: nesting to deep, maximum allowed is " + MAX_NESTING + ".";
+					break;
+				}
+			}
+			if (((opFound.flags() & OP_FRAG_ONLY) != 0) && !isFrag) {
+				_error = "error: opcode is only allowed in fragment programs.";
+				break;
+			}
+			if (verbose) trace("emit opcode=" + opFound);
+
+			_agalcode.writeUnsignedInt( opFound.emitCode() );
+			nops++;
+
+			if (nops > MAX_OPCODES) {
+				_error = "error: too many opcodes. maximum is " + MAX_OPCODES + ".";
+				break;
+			}
+
+// get operands, use regexp
+			reg = ~/vc\[([vof][actps]?)(\d*)?(\.[xyzw](\+\d{1,3})?)?\](\.[xyzw]{1,4})?|([vof][actps]?)(\d*)?(\.[xyzw]{1,4})?/gi;
+			var subline : String = line;
+			var regs : Array<String> = new Array<String>();
+			while (reg.match(subline)) {
+				regs.push(reg.matched(0));
+				subline = subline.substr(reg.matchedPos().pos + reg.matchedPos().len);
+				if (subline.charAt(0) == ",") subline = subline.substr(1);
+				reg = ~/vc\[([vof][actps]?)(\d*)?(\.[xyzw](\+\d{1,3})?)?\](\.[xyzw]{1,4})?|([vof][actps]?)(\d*)?(\.[xyzw]{1,4})?/gi;
+			}
+			if (regs.length != Std.int(opFound.numRegister())) {
+				_error = "error: wrong number of operands. found " + regs.length + " but expected " + opFound.numRegister + ".";
+				break;
+			}
+
+			var badreg : Bool    = false;
+			var pad : UInt       = 64 + 64 + 32;
+			var regLength : UInt = regs.length;
+
+			var j : Int = 0;
+			while (j < Std.int(regLength)) {
+				var isRelative : Bool = false;
+				reg = ~/\[.*\]/ig;
+				var relreg : String = "";
+				if (reg.match(regs[j])) {
+					relreg = reg.matched(0);
+					var relpos : Int = source.indexOf(relreg);
+					regs[j] = regs[j].substr(0, relpos) + "0" + regs[j].substr(relpos + relreg.length);
+
+					if (verbose) trace("IS REL");
+					isRelative = true;
+				}
+
+				reg = ~/^\b[A-Za-z]{1,2}/ig;
+				reg.match(regs[j]);
+				var res : String = reg.matched(0);
+				var regFound : Register = REGMAP.get(res);
+
+// if debug is enabled, output the registers
+				if (debugEnabled) trace(regFound);
+
+				if (regFound == null) {
+					_error = "error: could not parse operand " + j + " (" + regs[j] + ").";
+					badreg = true;
+					break;
+				}
+
+				if (isFrag) {
+					if ((regFound.flags() & REG_FRAG) == 0) {
+						_error = "error: register operand "+j+" ("+regs[j]+") only allowed in vertex programs.";
+						badreg = true;
+						break;
+					}
+					if (isRelative) {
+						_error = "error: register operand " + j + " (" + regs[j] + ") relative adressing not allowed in fragment programs.";
+						badreg = true;
+						break;
+					}
+				}
+				else {
+					if ((regFound.flags() & REG_VERT) == 0) {
+						_error = "error: register operand " + j + " (" + regs[j] + ") only allowed in fragment programs.";
+						badreg = true;
+						break;
+					}
+				}
+
+				regs[j] = regs[j].substr(regs[j].indexOf( regFound.name() ) + regFound.name().length);
+//trace( "REGNUM: " +regs[j] );
+				reg = ~/\d+/;
+				var idxmatched : Bool;
+				if (isRelative) idxmatched = reg.match(relreg);
+				else idxmatched = reg.match(regs[j]);
+
+				var regidx : UInt = 0;
+
+				if (idxmatched) regidx = Std.parseInt(reg.matched(0));
+
+				if (regFound.range() < regidx) {
+					_error = "error: register operand " + j + " (" + regs[j] + ") index exceeds limit of " + (regFound.range() + 1) + ".";
+					badreg = true;
+					break;
+				}
+
+				var regmask : UInt   = 0;
+				var isDest : Bool    = (j == 0 && (opFound.flags() & OP_NO_DEST) == 0);
+				var isSampler : Bool = (j == 2 && (opFound.flags() & OP_SPECIAL_TEX) != 0);
+				var reltype : UInt   = 0;
+				var relsel : UInt    = 0;
+				var reloffset : Int  = 0;
+
+				if (isDest && isRelative) {
+					_error = "error: relative can not be destination";
+					badreg = true;
+					break;
+				}
+
+				reg = ~/(\.[xyzw]{1,4})/;
+				if (reg.match(regs[j])) {
+					var maskmatch : String = reg.matched(0);
+					regmask = 0;
+					var cv : UInt = 0;
+					var maskLength : UInt = maskmatch.length;
+					var k : Int = 1;
+					while (k < Std.int(maskLength)) {
+						cv = maskmatch.charCodeAt(k) - "x".charCodeAt(0);
+						if (cv > 2) cv = 3;
+						if (isDest) regmask |= 1 << cv;
+						else regmask |= cv << ( ( k - 1 ) << 1 );
+						++k;
+					}
+					if (!isDest) {
+						while (k <= 4) {
+							regmask |= cv << ( ( k - 1 ) << 1 ); // repeat last
+							++k;
+						}
+					}
+				}
+				else regmask = isDest ? 0xf : 0xe4; // id swizzle or mask
+
+				if (isRelative) {
+					reg = ~/[A-Za-z]{1,2}/ig;
+					reg.match(relreg);
+					var relname : String = reg.matched(0);
+					var regFoundRel : Register = REGMAP.get(relname);
+					if (regFoundRel == null) {
+						_error = "error: bad index register";
+						badreg = true;
+						break;
+					}
+					reltype = regFoundRel.emitCode();
+					reg = ~/(\.[xyzw]{1,1})/;
+					if (!reg.match(relreg)) {
+						_error = "error: bad index register select";
+						badreg = true;
+						break;
+					}
+					var selmatch : String = reg.matched(0);
+					relsel = selmatch.charCodeAt(1) - "x".charCodeAt(0);
+					if (relsel > 2) relsel = 3;
+					reg = ~/\+\d{1,3}/ig;
+					if (reg.match(relreg)) {
+						reloffset = Std.parseInt(reg.matched(0));
+					}
+					if (reloffset < 0 || reloffset > 255) {
+						_error = "error: index offset "+reloffset+" out of bounds. [0..255]";
+						badreg = true;
+						break;
+					}
+					if (verbose) trace( "RELATIVE: type="+reltype+"=="+relname+" sel="+relsel+"=="+selmatch+" idx="+regidx+" offset="+reloffset );
+				}
+
+				if (verbose) trace("  emit argcode=" + regFound + "[" + regidx + "][" + regmask + "]");
+				if (isDest) {
+					_agalcode.writeShort(regidx);
+					_agalcode.writeByte(regmask);
+					_agalcode.writeByte(regFound.emitCode());
+					pad -= 32;
+				}
+				else {
+					if (isSampler) {
+						if (verbose) trace("  emit sampler");
+						var samplerbits : UInt = 5; // type 5
+						var optsLength:UInt = opts.length;
+						var bias:Float = 0;
+						var k : Int = 0;
+						while (k < Std.int(optsLength))
+						{
+							if (verbose)
+							{
+								trace("    opt: " + opts[k]);
+							}
+
+							var optfound:Sampler = SAMPLEMAP.get(opts[k]);
+							if (optfound == null)
+							{
+// todo check that it's a number...
+//trace( "Warning, unknown sampler option: "+opts[k] );
+								bias = Std.parseFloat(opts[k]);
+								if (verbose)
+								{
+									trace("    bias: " + bias);
+								}
+							}
+							else
+							{
+								if (optfound.flag() != SAMPLER_SPECIAL_SHIFT)
+								{
+									samplerbits &= ~(0xf << optfound.flag());
+								}
+
+								samplerbits |= optfound.mask() << optfound.flag();
+							}
+							++k;
+						}
+						_agalcode.writeShort(regidx);
+						_agalcode.writeByte(Std.int(bias * 8.0));
+						_agalcode.writeByte(0);
+						_agalcode.writeUnsignedInt(samplerbits);
+
+						if (verbose) trace("    bits: " + ( samplerbits - 5 ));
+						pad -= 64;
+					}
+					else {
+						if (j == 0) {
+							_agalcode.writeUnsignedInt(0);
+							pad -= 32;
+						}
+						_agalcode.writeShort(regidx);
+						_agalcode.writeByte(reloffset);
+						_agalcode.writeByte(regmask);
+						_agalcode.writeByte(regFound.emitCode());
+						_agalcode.writeByte(reltype);
+						_agalcode.writeShort(isRelative ? ( relsel | ( 1 << 15 ) ) : 0);
+
+						pad -= 64;
+					}
+				}
+				++j;
+			}
+
+// pad unused regs
+			j = 0;
+			while (j < Std.int(pad)) {
+				_agalcode.writeByte(0);
+				j += 8;
+			}
+
+			if (badreg) break;
+			++i;
+		}
+
+		if (_error != "") {
+			_error += "\n  at line " + i + " " + lines[i];
+			_agalcode.length = 0;
+			trace(_error);
+		}
+
+// trace the bytecode bytes if debugging is enabled
+		if (debugEnabled) {
+			var dbgLine : String = "generated bytecode:";
+			var agalLength : UInt = _agalcode.length;
+			var index : UInt = 0;
+			while (index < agalLength) {
+				if (( index % 16) == 0) dbgLine += "\n";
+				if ((index % 4) == 0) dbgLine += " ";
+
+				var byteStr : String = Std.string(_agalcode[index]);// .toString( 16 );
+				if (byteStr.length < 2) byteStr = "0" + byteStr;
+
+				dbgLine += byteStr;
+				++index;
+			}
+			trace( dbgLine );
+		}
+
+//if (verbose) trace( "AGALMiniAssembler.assemble time: " + ( ( getTimer() - start ) / 1000 ) + "s" );
+
+		return _agalcode;
+	}
+
+	static private function init() : Void {
+		initialized = true;
+
+// Fill the dictionaries with opcodes and registers
+		OPMAP.set(MOV, new OpCode(MOV, 2, 0x00, 0));
+		OPMAP.set(ADD, new OpCode(ADD, 3, 0x01, 0));
+		OPMAP.set(SUB, new OpCode(SUB, 3, 0x02, 0));
+		OPMAP.set(MUL, new OpCode(MUL, 3, 0x03, 0));
+		OPMAP.set(DIV, new OpCode(DIV, 3, 0x04, 0));
+		OPMAP.set(RCP, new OpCode(RCP, 2, 0x05, 0));
+		OPMAP.set(MIN, new OpCode(MIN, 3, 0x06, 0));
+		OPMAP.set(MAX, new OpCode(MAX, 3, 0x07, 0));
+		OPMAP.set(FRC, new OpCode(FRC, 2, 0x08, 0));
+		OPMAP.set(SQT, new OpCode(SQT, 2, 0x09, 0));
+		OPMAP.set(RSQ, new OpCode(RSQ, 2, 0x0a, 0));
+		OPMAP.set(POW, new OpCode(POW, 3, 0x0b, 0));
+		OPMAP.set(LOG, new OpCode(LOG, 2, 0x0c, 0));
+		OPMAP.set(EXP, new OpCode(EXP, 2, 0x0d, 0));
+		OPMAP.set(NRM, new OpCode(NRM, 2, 0x0e, 0));
+		OPMAP.set(SIN, new OpCode(SIN, 2, 0x0f, 0));
+		OPMAP.set(COS, new OpCode(COS, 2, 0x10, 0));
+		OPMAP.set(CRS, new OpCode(CRS, 3, 0x11, 0));
+		OPMAP.set(DP3, new OpCode(DP3, 3, 0x12, 0));
+		OPMAP.set(DP4, new OpCode(DP4, 3, 0x13, 0));
+		OPMAP.set(ABS, new OpCode(ABS, 2, 0x14, 0));
+		OPMAP.set(NEG, new OpCode(NEG, 2, 0x15, 0));
+		OPMAP.set(SAT, new OpCode(SAT, 2, 0x16, 0));
+		OPMAP.set(M33, new OpCode(M33, 3, 0x17, OP_SPECIAL_MATRIX));
+		OPMAP.set(M44, new OpCode(M44, 3, 0x18, OP_SPECIAL_MATRIX));
+		OPMAP.set(M34, new OpCode(M34, 3, 0x19, OP_SPECIAL_MATRIX));
+		OPMAP.set(IFZ, new OpCode(IFZ, 1, 0x1a, OP_NO_DEST | OP_INC_NEST | OP_SCALAR));
+		OPMAP.set(INZ, new OpCode(INZ, 1, 0x1b, OP_NO_DEST | OP_INC_NEST | OP_SCALAR));
+		OPMAP.set(IFE, new OpCode(IFE, 2, 0x1c, OP_NO_DEST | OP_INC_NEST | OP_SCALAR));
+		OPMAP.set(INE, new OpCode(INE, 2, 0x1d, OP_NO_DEST | OP_INC_NEST | OP_SCALAR));
+		OPMAP.set(IFG, new OpCode(IFG, 2, 0x1e, OP_NO_DEST | OP_INC_NEST | OP_SCALAR));
+		OPMAP.set(IFL, new OpCode(IFL, 2, 0x1f, OP_NO_DEST | OP_INC_NEST | OP_SCALAR));
+		OPMAP.set(IEG, new OpCode(IEG, 2, 0x20, OP_NO_DEST | OP_INC_NEST | OP_SCALAR));
+		OPMAP.set(IEL, new OpCode(IEL, 2, 0x21, OP_NO_DEST | OP_INC_NEST | OP_SCALAR));
+		OPMAP.set(ELS, new OpCode(ELS, 0, 0x22, OP_NO_DEST | OP_INC_NEST | OP_DEC_NEST));
+		OPMAP.set(EIF, new OpCode(EIF, 0, 0x23, OP_NO_DEST | OP_DEC_NEST));
+		OPMAP.set(REP, new OpCode(REP, 1, 0x24, OP_NO_DEST | OP_INC_NEST | OP_SCALAR));
+		OPMAP.set(ERP, new OpCode(ERP, 0, 0x25, OP_NO_DEST | OP_DEC_NEST));
+		OPMAP.set(BRK, new OpCode(BRK, 0, 0x26, OP_NO_DEST));
+		OPMAP.set(KIL, new OpCode(KIL, 1, 0x27, OP_NO_DEST | OP_FRAG_ONLY));
+		OPMAP.set(TEX, new OpCode(TEX, 3, 0x28, OP_FRAG_ONLY | OP_SPECIAL_TEX));
+		OPMAP.set(SGE, new OpCode(SGE, 3, 0x29, 0));
+		OPMAP.set(SLT, new OpCode(SLT, 3, 0x2a, 0));
+		OPMAP.set(SGN, new OpCode(SGN, 2, 0x2b, 0));
+
+		REGMAP.set(VA, new Register(VA,  "vertex attribute",   0x0,   7, REG_VERT | REG_READ));
+		REGMAP.set(VC, new Register(VC,  "vertex constant",    0x1, 127, REG_VERT | REG_READ));
+		REGMAP.set(VT, new Register(VT,  "vertex temporary",   0x2,   7, REG_VERT | REG_WRITE | REG_READ));
+		REGMAP.set(OP, new Register(OP,  "vertex output",      0x3,   0, REG_VERT | REG_WRITE));
+		REGMAP.set( V, new Register( V,  "varying",            0x4,   7, REG_VERT | REG_FRAG | REG_READ | REG_WRITE));
+		REGMAP.set(FC, new Register(FC,  "fragment constant",  0x1,  27, REG_FRAG | REG_READ));
+		REGMAP.set(FT, new Register(FT,  "fragment temporary", 0x2,   7, REG_FRAG | REG_WRITE | REG_READ));
+		REGMAP.set(FS, new Register(FS,  "texture sampler",    0x5,   7, REG_FRAG | REG_READ));
+		REGMAP.set(OC, new Register(OC,  "fragment output",    0x3,   0, REG_FRAG | REG_WRITE));
+
+		SAMPLEMAP.set(D2,         new Sampler(D2,         SAMPLER_DIM_SHIFT,     0));
+		SAMPLEMAP.set(D3,         new Sampler(D3,         SAMPLER_DIM_SHIFT,     2));
+		SAMPLEMAP.set(CUBE,       new Sampler(CUBE,       SAMPLER_DIM_SHIFT,     1));
+		SAMPLEMAP.set(MIPNEAREST, new Sampler(MIPNEAREST, SAMPLER_MIPMAP_SHIFT,  1));
+		SAMPLEMAP.set(MIPLINEAR,  new Sampler(MIPLINEAR,  SAMPLER_MIPMAP_SHIFT,  2));
+		SAMPLEMAP.set(MIPNONE,    new Sampler(MIPNONE,    SAMPLER_MIPMAP_SHIFT,  0));
+		SAMPLEMAP.set(NOMIP,      new Sampler(NOMIP,      SAMPLER_MIPMAP_SHIFT,  0));
+		SAMPLEMAP.set(NEAREST,    new Sampler(NEAREST,    SAMPLER_FILTER_SHIFT,  0));
+		SAMPLEMAP.set(LINEAR,     new Sampler(LINEAR,     SAMPLER_FILTER_SHIFT,  1));
+		SAMPLEMAP.set(CENTROID,   new Sampler(CENTROID,   SAMPLER_SPECIAL_SHIFT, 1 << 0));
+		SAMPLEMAP.set(SINGLE,     new Sampler(SINGLE,     SAMPLER_SPECIAL_SHIFT, 1 << 1));
+		SAMPLEMAP.set(DEPTH,      new Sampler(DEPTH,      SAMPLER_SPECIAL_SHIFT, 1 << 2));
+		SAMPLEMAP.set(REPEAT,     new Sampler(REPEAT,     SAMPLER_REPEAT_SHIFT,  1));
+		SAMPLEMAP.set(WRAP,       new Sampler(WRAP,       SAMPLER_REPEAT_SHIFT,  1));
+		SAMPLEMAP.set(CLAMP,      new Sampler(CLAMP,      SAMPLER_REPEAT_SHIFT,  0));
+	}
+
+// ======================================================================
+//  Constants
+// ----------------------------------------------------------------------
+	private static var OPMAP : Hash<OpCode>      = new Hash<OpCode>();
+	private static var REGMAP : Hash<Register>   = new Hash<Register>();
+	private static var SAMPLEMAP : Hash<Sampler> = new Hash<Sampler>();
+
+	private static var MAX_NESTING : Int         = 4;
+	private static var MAX_OPCODES : Int         = 256;
+
+	private static var FRAGMENT : String         = "fragment";
+	private static var VERTEX : String           = "vertex";
+
+// masks and shifts
+	private static var SAMPLER_DIM_SHIFT : UInt     = 12;
+	private static var SAMPLER_SPECIAL_SHIFT : UInt = 16;
+	private static var SAMPLER_REPEAT_SHIFT : UInt  = 20;
+	private static var SAMPLER_MIPMAP_SHIFT : UInt  = 24;
+	private static var SAMPLER_FILTER_SHIFT : UInt  = 28;
+
+// regmap flags
+	private static var REG_WRITE : UInt           = 0x1;
+	private static var REG_READ : UInt            = 0x2;
+	private static var REG_FRAG : UInt            = 0x20;
+	private static var REG_VERT : UInt            = 0x40;
+
+// opmap flags
+	private static var OP_SCALAR : UInt            = 0x1;
+	private static var OP_INC_NEST : UInt          = 0x2;
+	private static var OP_DEC_NEST : UInt          = 0x4;
+	private static var OP_SPECIAL_TEX : UInt       = 0x8;
+	private static var OP_SPECIAL_MATRIX : UInt    = 0x10;
+	private static var OP_FRAG_ONLY : UInt         = 0x20;
+	private static var OP_VERT_ONLY : UInt         = 0x40;
+	private static var OP_NO_DEST : UInt           = 0x80;
+
+// opcodes
+	private static var MOV : String              = "mov";
+	private static var ADD : String              = "add";
+	private static var SUB : String              = "sub";
+	private static var MUL : String              = "mul";
+	private static var DIV : String              = "div";
+	private static var RCP : String              = "rcp";
+	private static var MIN : String              = "min";
+	private static var MAX : String              = "max";
+	private static var FRC : String              = "frc";
+	private static var SQT : String              = "sqt";
+	private static var RSQ : String              = "rsq";
+	private static var POW : String              = "pow";
+	private static var LOG : String              = "log";
+	private static var EXP : String              = "exp";
+	private static var NRM : String              = "nrm";
+	private static var SIN : String              = "sin";
+	private static var COS : String              = "cos";
+	private static var CRS : String              = "crs";
+	private static var DP3 : String              = "dp3";
+	private static var DP4 : String              = "dp4";
+	private static var ABS : String              = "abs";
+	private static var NEG : String              = "neg";
+	private static var SAT : String              = "sat";
+	private static var M33 : String              = "m33";
+	private static var M44 : String              = "m44";
+	private static var M34 : String              = "m34";
+	private static var IFZ : String              = "ifz";
+	private static var INZ : String              = "inz";
+	private static var IFE : String              = "ife";
+	private static var INE : String              = "ine";
+	private static var IFG : String              = "ifg";
+	private static var IFL : String              = "ifl";
+	private static var IEG : String              = "ieg";
+	private static var IEL : String              = "iel";
+	private static var ELS : String              = "els";
+	private static var EIF : String              = "eif";
+	private static var REP : String              = "rep";
+	private static var ERP : String              = "erp";
+	private static var BRK : String              = "brk";
+	private static var KIL : String              = "kil";
+	private static var TEX : String              = "tex";
+	private static var SGE : String              = "sge";
+	private static var SLT : String              = "slt";
+	private static var SGN : String              = "sgn";
+
+// registers
+	private static var VA : String              = "va";
+	private static var VC : String              = "vc";
+	private static var VT : String              = "vt";
+	private static var OP : String              = "op";
+	private static var V  : String              = "v";
+	private static var FC : String              = "fc";
+	private static var FT : String              = "ft";
+	private static var FS : String              = "fs";
+	private static var OC : String              = "oc";
+
+// samplers
+	private static var D2 : String              = "2d";
+	private static var D3 : String              = "3d";
+	private static var CUBE : String            = "cube";
+	private static var MIPNEAREST : String      = "mipnearest";
+	private static var MIPLINEAR : String       = "miplinear";
+	private static var MIPNONE : String         = "mipnone";
+	private static var NOMIP : String           = "nomip";
+	private static var NEAREST : String         = "nearest";
+	private static var LINEAR : String          = "linear";
+	private static var CENTROID : String        = "centroid";
+	private static var SINGLE : String          = "single";
+	private static var DEPTH : String           = "depth";
+	private static var REPEAT : String          = "repeat";
+	private static var WRAP : String            = "wrap";
+	private static var CLAMP : String           = "clamp";
+}
+
+// ================================================================================
+//  Helper Classes
+// --------------------------------------------------------------------------------
+
+// ===========================================================================
+//  Class
+// ---------------------------------------------------------------------------
+class OpCode {
+// ======================================================================
+//  Properties
+// ----------------------------------------------------------------------
+	private var _emitCode : UInt;
+	private var _flags : UInt;
+	private var _name : String;
+	private var _numRegister : UInt;
+
+// ======================================================================
+//  Getters
+// ----------------------------------------------------------------------
+	public function emitCode() : UInt    { return _emitCode; }
+	public function flags() : UInt       { return _flags; }
+	public function name() : String      { return _name; }
+	public function numRegister() : UInt { return _numRegister; }
+
+// ======================================================================
+//  Constructor
+// ----------------------------------------------------------------------
+	public function new(name : String, numRegister : UInt, emitCode : UInt, flags : UInt) {
+		_name = name;
+		_numRegister = numRegister;
+		_emitCode = emitCode;
+		_flags = flags;
+	}
+
+// ======================================================================
+//  Methods
+// ----------------------------------------------------------------------
+	public function toString() : String {
+		return "[OpCode name=\"" + _name + "\", numRegister=" + _numRegister + ", emitCode=" + _emitCode + ", flags=" + _flags + "]";
+	}
+}
+
+// ===========================================================================
+//  Class
+// ---------------------------------------------------------------------------
+class Register {
+// ======================================================================
+//  Properties
+// ----------------------------------------------------------------------
+	private var _emitCode : UInt;
+	private var _name:String;
+	private var _longName:String;
+	private var _flags:UInt;
+	private var _range:UInt;
+
+// ======================================================================
+//  Getters
+// ----------------------------------------------------------------------
+	public function emitCode() : UInt   { return _emitCode; }
+	public function longName() : String { return _longName; }
+	public function name() : String     { return _name; }
+	public function flags() : UInt      { return _flags; }
+	public function range() : UInt      { return _range; }
+
+// ======================================================================
+//  Constructor
+// ----------------------------------------------------------------------
+	public function new(name : String, longName : String, emitCode : UInt, range : UInt, flags : UInt) {
+		_name = name;
+		_longName = longName;
+		_emitCode = emitCode;
+		_range = range;
+		_flags = flags;
+	}
+
+// ======================================================================
+//  Methods
+// ----------------------------------------------------------------------
+	public function toString() : String {
+		return "[Register name=\"" + _name + "\", longName=\"" + _longName + "\", emitCode=" + _emitCode + ", range=" + _range + ", flags=" + _flags + "]";
+	}
+}
+
+// ===========================================================================
+//  Class
+// ---------------------------------------------------------------------------
+class Sampler {
+// ======================================================================
+//  Properties
+// ----------------------------------------------------------------------
+	private var _flag : UInt;
+	private var _mask : UInt;
+	private var _name : String;
+
+// ======================================================================
+//  Getters
+// ----------------------------------------------------------------------
+	public function flag() : UInt    { return _flag; }
+	public function mask() : UInt    { return _mask; }
+	public function name() : String  { return _name; }
+
+// ======================================================================
+//  Constructor
+// ----------------------------------------------------------------------
+	public function new(name : String, flag : UInt, mask : UInt) {
+		_name = name;
+		_flag = flag;
+		_mask = mask;
+	}
+
+// ======================================================================
+//  Methods
+// ----------------------------------------------------------------------
+	public function toString() : String {
+		return "[Sampler name=\"" + _name + "\", flag=\"" + _flag + "\", mask=" + mask + "]";
+	}
+}
\ No newline at end of file
diff --git a/native/display/Stage.hx b/native/display/Stage.hx
index 0b6cbf4..361da69 100644
--- a/native/display/Stage.hx
+++ b/native/display/Stage.hx
@@ -1,6 +1,7 @@
 package native.display;
 
 
+import nme.Vector;
 import haxe.Timer;
 import native.display.DisplayObjectContainer;
 import native.events.JoystickEvent;
@@ -15,6 +16,7 @@ import native.Lib;
 import native.media.SoundChannel;
 import native.net.URLLoader;
 import native.Loader;
+import native.display.Stage3D;
 
 
 class Stage extends DisplayObjectContainer {
@@ -51,6 +53,7 @@ class Stage extends DisplayObjectContainer {
 	public var stageFocusRect (get_stageFocusRect, set_stageFocusRect):Bool;
 	public var stageHeight (get_stageHeight, null):Int;
 	public var stageWidth (get_stageWidth, null):Int;
+    public var stage3Ds : Vector<Stage3D>;
 	
 	private static var efLeftDown = 0x0001;
 	private static var efShiftDown = 0x0002;
@@ -103,6 +106,9 @@ class Stage extends DisplayObjectContainer {
 		this.frameRate = 100;
 		nmeTouchInfo = new IntHash<TouchInfo> ();
 		nmeJoyAxisData = new IntHash<Array<Float>> ();
+
+        stage3Ds = new Vector();
+        stage3Ds.push(new Stage3D());
 		
 	}
 	
diff --git a/native/display/Stage3D.hx b/native/display/Stage3D.hx
new file mode 100644
index 0000000..1bb3642
--- /dev/null
+++ b/native/display/Stage3D.hx
@@ -0,0 +1,22 @@
+package native.display;
+
+import nme.events.EventDispatcher;
+import nme.events.Event;
+import nme.events.ErrorEvent;
+import native.display3D.Context3D;
+
+class Stage3D extends EventDispatcher{
+
+    public var context3D : Context3D;
+
+    public function new() {
+        super();
+    }
+
+    public function requestContext3D() : Void{
+        context3D = new Context3D();
+        dispatchEvent(new Event(Event.CONTEXT3D_CREATE));
+
+        // TODO ErrorEvent ?
+    }
+}
diff --git a/native/display3D/Context3D.hx b/native/display3D/Context3D.hx
new file mode 100644
index 0000000..bb9e047
--- /dev/null
+++ b/native/display3D/Context3D.hx
@@ -0,0 +1,212 @@
+package native.display3D;
+
+import nme.errors.Error;
+import nme.display3D.Context3DVertexBufferFormat;
+import native.display3D.Program3D;
+import native.geom.Rectangle;
+import nme.display3D.IndexBuffer3D;
+import nme.display3D.VertexBuffer3D;
+import nme.display3D.textures.Texture;
+import native.display3D.Context3DTextureFormat;
+import nme.display3D.Program3D;
+
+import native.gl.GL;
+
+class Context3D {
+
+    private var currentProgram : Program3D;
+
+	private var ogl : native.display.OpenGLView;
+
+
+    // to mimic stage3d behavior of keeping blendign accross frame:
+    private var blendEnabled : Bool = false;
+    private var blendSourceFactor : Int;
+    private var blendDestinationFactor : Int;
+
+    // to mimc stage3d behavior of not allowing to call drawTriangles between present and clear
+    private var drawing : Bool;
+
+    public function new() {
+	    var stage = nme.Lib.current.stage;
+
+	    ogl = new native.display.OpenGLView();
+
+	    ogl.scrollRect = new nme.geom.Rectangle(0,0,stage.stageWidth,stage.stageHeight);
+	    ogl.width = stage.stageWidth;
+	    ogl.height = stage.stageHeight;
+	    stage.addChildAt(ogl, 0);
+    }
+
+	public function setRenderMethod(func : Rectangle -> Void) : Void{
+	    ogl.render = func;
+	}
+
+	public function clear(red : Float = 0, green : Float = 0, blue : Float = 0, alpha : Float = 1, depth : Float = 1, stencil : Int = 0, mask : Int = Context3DClearMask.ALL) : Void{
+
+        if(drawing == false){
+            updateBlendStatus();
+            drawing = true;
+        }
+
+		// TODO do not set clear color if not necessary ?
+		GL.clearColor(red,green,blue,alpha);
+        GL.clearDepth(depth);
+        GL.clearStencil(stencil);
+
+		GL.clear(mask);
+	}
+
+	public function configureBackBuffer(width : Int, height : Int, antiAlias : Int, enableDepthAndStencil : Bool = true) : Void{
+		ogl.scrollRect = new nme.geom.Rectangle(0,0,width,height);   // TODO use other arguments
+	}
+
+	public function createIndexBuffer(numIndices : Int) : IndexBuffer3D{
+		return new IndexBuffer3D(GL.createBuffer(), numIndices);  // TODO use arguments ?
+	}
+
+
+	public function createTexture(width : Int, height : Int, format : Context3DTextureFormat, optimizeForRenderToTexture : Bool, streamingLevels : Int = 0) : Texture{
+		return new native.display3D.textures.Texture(GL.createTexture());     // TODO use arguments ?
+	}
+
+	public function createVertexBuffer(numVertices : Int, data32PerVertex : Int) : VertexBuffer3D{
+		return new VertexBuffer3D(GL.createBuffer(), numVertices, data32PerVertex);      // TODO use arguments ?
+	}
+
+	public function dispose() : Void{
+		// TODO
+	}
+
+
+	public function drawTriangles(indexBuffer : IndexBuffer3D, firstIndex : Int = 0, numTriangles : Int = -1) : Void{
+        if(!drawing){
+            throw new Error("Need To Clear Before Draw: If the buffer has not been cleared since the last present() call.");
+        }
+        var numIndices;
+        if(numTriangles == -1){
+            numIndices = indexBuffer.numIndices;
+        }else{
+            numIndices = numTriangles * 3;
+        }
+		GL.drawElements(GL.TRIANGLES, numIndices, GL.UNSIGNED_SHORT, firstIndex);
+	}
+
+	public function present() : Void{
+        drawing = false;
+		GL.useProgram(null);
+	}
+
+	public function setColorMask(red : Bool, green : Bool, blue : Bool, alpha : Bool) : Void{
+		GL.colorMask(red, green, blue, alpha);
+	}
+
+	public function setBlendFactors(sourceFactor :Int, destinationFactor : Int) : Void{
+		blendEnabled = true;
+        blendSourceFactor = sourceFactor;
+        blendDestinationFactor = destinationFactor;
+        updateBlendStatus();
+	}
+
+    private function updateBlendStatus() : Void{
+        if(blendEnabled){
+            GL.enable(GL.BLEND);
+            GL.blendEquation(GL.FUNC_ADD);
+            GL.blendFunc(blendSourceFactor, blendDestinationFactor);
+        }else{
+            GL.disable(GL.BLEND);
+        }
+    }
+
+    public function createProgram() : Program3D{
+        return new Program3D(GL.createProgram());
+    }
+
+    public function setProgram(program3D : Program3D) : Void{
+        var glProgram : Program = null;
+        if (program3D != null){
+            glProgram = program3D.glProgram;
+        }
+        GL.useProgram(glProgram);
+        currentProgram = program3D;
+    }
+
+    public function setProgramConstantsFromMatrix(programType : Int, firstRegister : Int, matrix : nme.geom.Matrix3D, transposedMatrix : Bool = false) : Void{
+        var uniformPrefix =
+        switch(programType){
+            case Context3DProgramType.VERTEX: "vc";
+            case Context3DProgramType.FRAGMENT: "fc";
+            default : throw "program Type " + programType + " not supported";
+        };
+        var location = GL.getUniformLocation(currentProgram.glProgram, uniformPrefix + firstRegister);
+        GL.uniformMatrix3D(location, !transposedMatrix, matrix);
+    }
+
+    // TODO use TextureBase
+    public function setTextureAt(sampler : Int, texture : nme.display3D.textures.Texture) : Void{
+        var location =  GL.getUniformLocation(currentProgram.glProgram, "fs" + sampler);
+
+        // TODO multiple active textures (get an id from the Texture Wrapper (native.display3D.textures.Texture) ? )
+        GL.activeTexture(GL.TEXTURE0);
+
+        GL.bindTexture(GL.TEXTURE_2D, texture.glTexture);
+        GL.uniform1i(location, 0);
+
+        // TODO : should this be defined in the shader ? in some way?
+        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE );
+        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE );
+        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR);
+        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.LINEAR);
+        /////////////////////////////////////////////////////////////////
+    }
+
+    public function setVertexBufferAt(index : Int, buffer : VertexBuffer3D, bufferOffset : Int = 0, ?format : Context3DVertexBufferFormat) : Void{
+        var location = GL.getAttribLocation(currentProgram.glProgram, "va" + index);
+        GL.bindBuffer(GL.ARRAY_BUFFER, buffer.glBuffer);
+        var dimension : Int = 4;
+        var type : Int = GL.FLOAT;
+        var numBytes : Int =4;
+        switch(format){
+            case  Context3DVertexBufferFormat.BYTES_4:
+                dimension = 4;
+                type = GL.FLOAT;
+                numBytes = 4;
+            case Context3DVertexBufferFormat.FLOAT_1 :
+                dimension = 1;
+                type = GL.FLOAT;
+                numBytes = 4;
+            case Context3DVertexBufferFormat.FLOAT_2 :
+                dimension = 2;
+                type = GL.FLOAT;
+                numBytes = 4;
+            case Context3DVertexBufferFormat.FLOAT_3 :
+                dimension = 3;
+                type = GL.FLOAT;
+                numBytes = 4;
+
+            case Context3DVertexBufferFormat.FLOAT_4 :
+                dimension = 4;
+                type = GL.FLOAT;
+                numBytes = 4;
+            default : throw "Buffer format " + format + " not supported";
+        }
+        GL.vertexAttribPointer(location, dimension, type, false, buffer.data32PerVertex * numBytes, bufferOffset * numBytes);
+        GL.enableVertexAttribArray(location);
+    }
+
+    // should be enum Context3DTriangleFace
+    public function setCulling(triangleFaceToCull : Int) : Void{
+        GL.cullFace(triangleFaceToCull);
+        GL.enable(GL.CULL_FACE);
+    }
+
+// TODO but currently Context3DCompare has wrong value for Depth Test (see native.gl.GL)
+    //passCompareMode should be enum  Context3DCompareMode
+//    public function setDepthTest(depthMask : Bool, passCompareMode : Int) : Void{
+//        GL.depthFunc(passCompareMode);
+//        GL.enable(GL.DEPTH_TEST);
+//        GL.enable(GL.STENCIL_TEST);
+//        GL.depthMask(depthMask);
+//    }
+
+}
diff --git a/native/display3D/Context3DBlendFactor.hx b/native/display3D/Context3DBlendFactor.hx
new file mode 100644
index 0000000..51acb84
--- /dev/null
+++ b/native/display3D/Context3DBlendFactor.hx
@@ -0,0 +1,16 @@
+package native.display3D;
+
+import nme.gl.GL;
+
+class Context3DBlendFactor {
+	inline public static var DESTINATION_ALPHA : Int = GL.DST_ALPHA;
+	inline public static var DESTINATION_COLOR : Int = GL.DST_COLOR;
+	inline public static var ONE : Int = GL.ONE;
+	inline public static var ONE_MINUS_DESTINATION_ALPHA : Int = GL.ONE_MINUS_DST_ALPHA;
+	inline public static var ONE_MINUS_DESTINATION_COLOR : Int = GL.ONE_MINUS_DST_COLOR;
+	inline public static var ONE_MINUS_SOURCE_ALPHA : Int = GL.ONE_MINUS_SRC_ALPHA;
+	inline public static var ONE_MINUS_SOURCE_COLOR : Int = GL.ONE_MINUS_SRC_COLOR;
+	inline public static var SOURCE_ALPHA : Int = GL.SRC_ALPHA;
+	inline public static var SOURCE_COLOR : Int = GL.SRC_COLOR;
+	inline public static var ZERO : Int = GL.ZERO;
+}
diff --git a/native/display3D/Context3DClearMask.hx b/native/display3D/Context3DClearMask.hx
new file mode 100644
index 0000000..27d3a8a
--- /dev/null
+++ b/native/display3D/Context3DClearMask.hx
@@ -0,0 +1,8 @@
+package native.display3D;
+import nme.gl.GL;
+class Context3DClearMask {
+    inline static public var ALL : Int = COLOR | DEPTH | STENCIL;
+    inline static public var COLOR : Int = GL.COLOR_BUFFER_BIT;
+    inline static public var DEPTH : Int = GL.DEPTH_BUFFER_BIT;
+    inline static public var STENCIL : Int = GL.STENCIL_BUFFER_BIT;
+}
diff --git a/native/display3D/Context3DCompareMode.hx b/native/display3D/Context3DCompareMode.hx
new file mode 100644
index 0000000..1f3b304
--- /dev/null
+++ b/native/display3D/Context3DCompareMode.hx
@@ -0,0 +1,14 @@
+package native.display3D;
+
+import native.gl.GL;
+
+class Context3DCompareMode {
+    inline static public var ALWAYS = GL.ALWAYS;
+    inline static public var EQUAL = GL.EQUAL;
+    inline static public var GREATER = GL.GREATER;
+    inline static public var GREATER_EQUAL = GL.GEQUAL;
+    inline static public var LESS = GL.LESS;
+    inline static public var LESS_EQUAL = GL.LEQUAL; // TODO : wrong value
+    inline static public var NEVER = GL.NEVER;
+    inline static public var NOT_EQUAL = GL.NOTEQUAL;
+}
diff --git a/native/display3D/Context3DProgramType.hx b/native/display3D/Context3DProgramType.hx
new file mode 100644
index 0000000..92ecea4
--- /dev/null
+++ b/native/display3D/Context3DProgramType.hx
@@ -0,0 +1,8 @@
+package native.display3D;
+
+import nme.gl.GL;
+
+class Context3DProgramType {
+    inline public static var VERTEX = GL.VERTEX_SHADER;
+    inline public static var FRAGMENT = GL.FRAGMENT_SHADER;
+}
diff --git a/native/display3D/Context3DTextureFormat.hx b/native/display3D/Context3DTextureFormat.hx
new file mode 100644
index 0000000..84bc20f
--- /dev/null
+++ b/native/display3D/Context3DTextureFormat.hx
@@ -0,0 +1,9 @@
+package native.display3D;
+
+@:fakeEnum(String) extern enum Context3DTextureFormat {
+    BGRA;
+    COMPRESSED;
+    COMPRESSED_ALPHA;
+
+}
+
diff --git a/native/display3D/Context3DTriangleFace.hx b/native/display3D/Context3DTriangleFace.hx
new file mode 100644
index 0000000..a4263c4
--- /dev/null
+++ b/native/display3D/Context3DTriangleFace.hx
@@ -0,0 +1,9 @@
+package native.display3D;
+import nme.gl.GL;
+
+class Context3DTriangleFace {
+    inline public static var BACK = GL.FRONT;
+    inline public static var FRONT = GL.BACK;
+    inline public static var FRONT_AND_BACK = GL.FRONT_AND_BACK;
+    inline public static var NONE = 0;
+}
diff --git a/native/display3D/Context3DVertexBufferFormat.hx b/native/display3D/Context3DVertexBufferFormat.hx
new file mode 100644
index 0000000..042d7f3
--- /dev/null
+++ b/native/display3D/Context3DVertexBufferFormat.hx
@@ -0,0 +1,9 @@
+package native.display3D;
+
+@:fakeEnum(String) extern enum Context3DVertexBufferFormat {
+    BYTES_4;
+    FLOAT_1;
+    FLOAT_2;
+    FLOAT_3;
+    FLOAT_4;
+}
diff --git a/native/display3D/IndexBuffer3D.hx b/native/display3D/IndexBuffer3D.hx
new file mode 100644
index 0000000..75f26c1
--- /dev/null
+++ b/native/display3D/IndexBuffer3D.hx
@@ -0,0 +1,17 @@
+package native.display3D;
+import nme.utils.ByteArray;
+import nme.gl.GL;
+class IndexBuffer3D {
+    public var glBuffer : nme.gl.Buffer;
+    public var numIndices : Int;
+    public function new(glBuffer : nme.gl.Buffer, numIndices : Int) {
+        this.glBuffer = glBuffer;
+        this.numIndices = numIndices;
+    }
+
+    public function uploadFromByteArray(byteArray : ByteArray, byteArrayOffset : Int, startOffset : Int, count : Int): Void{
+        // TODO deal with other agruments   ?
+        GL.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, glBuffer);
+        GL.bufferData(GL.ELEMENT_ARRAY_BUFFER, byteArray, GL.STATIC_DRAW);
+    }
+}
\ No newline at end of file
diff --git a/native/display3D/Program3D.hx b/native/display3D/Program3D.hx
new file mode 100644
index 0000000..2d79d83
--- /dev/null
+++ b/native/display3D/Program3D.hx
@@ -0,0 +1,24 @@
+package native.display3D;
+
+import nme.gl.GL;
+
+class Program3D {
+
+    public var glProgram : Program;
+
+    public function new(program : Program) {
+        this.glProgram = program;
+    }
+
+    public function upload(vertexShader : Shader, fragmentShader : Shader) : Void{
+        GL.attachShader(glProgram, vertexShader);
+		GL.attachShader(glProgram, fragmentShader);
+		GL.linkProgram(glProgram);
+		if (GL.getProgramParameter(glProgram, GL.LINK_STATUS)==0)
+		{
+			var result = GL.getProgramInfoLog(glProgram);
+			if (result!="")
+				throw result;
+		}
+    }
+}
diff --git a/native/display3D/VertexBuffer3D.hx b/native/display3D/VertexBuffer3D.hx
new file mode 100644
index 0000000..c483cf3
--- /dev/null
+++ b/native/display3D/VertexBuffer3D.hx
@@ -0,0 +1,19 @@
+package native.display3D;
+import nme.utils.ByteArray;
+import nme.gl.GL;
+class VertexBuffer3D {
+    public var glBuffer : nme.gl.Buffer;
+    public var numVertices : Int;
+    public var data32PerVertex : Int;
+    public function new(glBuffer : nme.gl.Buffer, numVertices : Int, data32PerVertex : Int) {
+        this.glBuffer = glBuffer;
+        this.numVertices = numVertices;
+        this.data32PerVertex = data32PerVertex;
+    }
+
+    public function uploadFromByteArray(byteArray : ByteArray, byteArrayOffset : Int, startOffset : Int, count : Int): Void{
+        // TODO deal with other agruments   ?
+        GL.bindBuffer(GL.ARRAY_BUFFER, glBuffer);
+        GL.bufferData(GL.ARRAY_BUFFER, byteArray, GL.STATIC_DRAW);
+    }
+}
\ No newline at end of file
diff --git a/native/display3D/textures/Texture.hx b/native/display3D/textures/Texture.hx
new file mode 100644
index 0000000..6d007fb
--- /dev/null
+++ b/native/display3D/textures/Texture.hx
@@ -0,0 +1,28 @@
+package native.display3D.textures;
+import nme.display.BitmapData;
+import nme.gl.GL;
+import nme.utils.ArrayBuffer;
+import nme.utils.ArrayBufferView;
+class Texture {
+    public var glTexture : nme.gl.Texture;
+    public function new(glTexture : nme.gl.Texture) {
+        this.glTexture = glTexture;
+    }
+
+    public function uploadFromBitmapData(bitmapData : BitmapData) : Void{
+        GL.bindTexture(GL.TEXTURE_2D, glTexture);
+        var p = bitmapData.getPixels(new nme.geom.Rectangle(0,0, bitmapData.width, bitmapData.height));
+        var num =  bitmapData.width * bitmapData.height;
+        for (i in 0...num){
+            var alpha = p[i * 4];
+            var red = p[i * 4 + 1];
+            var green = p[i * 4 + 2];
+            var blue = p[i * 4 + 3];
+            p[i * 4] = red;
+            p[i * 4 + 1] = green;
+            p[i * 4 + 2] = blue;
+            p[i * 4 + 3] = alpha;
+        }
+        GL.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA, bitmapData.width, bitmapData.height, 0, GL.RGBA, GL.UNSIGNED_BYTE, new ArrayBufferView(p , 0));
+    }
+}
diff --git a/native/events/ErrorEvent.hx b/native/events/ErrorEvent.hx
index 57010e0..2c6fcf5 100644
--- a/native/events/ErrorEvent.hx
+++ b/native/events/ErrorEvent.hx
@@ -2,8 +2,9 @@ package native.events;
 
 
 class ErrorEvent extends TextEvent {
-	
-	
+
+    public static var ERROR = "error";
+
 	public var errorID (default, null):Int;
 	
 	
diff --git a/native/events/Event.hx b/native/events/Event.hx
index f38f3cf..b787dd4 100644
--- a/native/events/Event.hx
+++ b/native/events/Event.hx
@@ -29,6 +29,7 @@ class Event {
 	public static var TAB_ENABLED_CHANGE = "tabEnabledChange";
 	public static var TAB_INDEX_CHANGE = "tabIndexChange";
 	public static var UNLOAD = "unload";
+    public static var CONTEXT3D_CREATE = "context3DCreate";
 	
 	public var bubbles (get_bubbles, never):Bool;
 	public var cancelable (get_cancelable, never):Bool;
diff --git a/nme/display/Stage3D.hx b/nme/display/Stage3D.hx
new file mode 100644
index 0000000..cb23b34
--- /dev/null
+++ b/nme/display/Stage3D.hx
@@ -0,0 +1,7 @@
+package nme.display;
+
+#if flash
+typedef Stage3D = flash.display.Stage3D;
+#elseif cpp
+typedef Stage3D = native.display.Stage3D;
+#end
diff --git a/nme/display3D/Context3D.hx b/nme/display3D/Context3D.hx
new file mode 100644
index 0000000..856b85c
--- /dev/null
+++ b/nme/display3D/Context3D.hx
@@ -0,0 +1,7 @@
+package nme.display3D;
+
+#if flash
+	typedef Context3D =  flash.display3D.Context3D;
+#elseif cpp
+	typedef Context3D = native.display3D.Context3D;
+#end
\ No newline at end of file
diff --git a/nme/display3D/Context3DBlendFactor.hx b/nme/display3D/Context3DBlendFactor.hx
new file mode 100644
index 0000000..5bc48df
--- /dev/null
+++ b/nme/display3D/Context3DBlendFactor.hx
@@ -0,0 +1,6 @@
+package nme.display3D;
+#if flash
+typedef Context3DBlendFactor = flash.display3D.Context3DBlendFactor;
+#else
+typedef Context3DBlendFactor = native.display3D.Context3DBlendFactor;
+#end
diff --git a/nme/display3D/Context3DClearMask.hx b/nme/display3D/Context3DClearMask.hx
new file mode 100644
index 0000000..7ec2ea4
--- /dev/null
+++ b/nme/display3D/Context3DClearMask.hx
@@ -0,0 +1,6 @@
+package nme.display3D;
+#if flash
+typedef Context3DClearMask = flash.display3D.Context3DClearMask;
+#elseif cpp
+typedef Context3DClearMask = native.display3D.Context3DClearMask;
+#end
diff --git a/nme/display3D/Context3DCompareMode.hx b/nme/display3D/Context3DCompareMode.hx
new file mode 100644
index 0000000..b8c910e
--- /dev/null
+++ b/nme/display3D/Context3DCompareMode.hx
@@ -0,0 +1,7 @@
+package nme.display3D;
+
+#if flash
+typedef Context3DCompareMode = flash.display3D.Context3DCompareMode;
+#elseif cpp
+typedef Context3DCompareMode = native.display3D.Context3DCompareMode;
+#end
diff --git a/nme/display3D/Context3DProgramType.hx b/nme/display3D/Context3DProgramType.hx
new file mode 100644
index 0000000..3aed847
--- /dev/null
+++ b/nme/display3D/Context3DProgramType.hx
@@ -0,0 +1,7 @@
+package nme.display3D;
+
+#if flash
+typedef Context3DProgramType = flash.display3D.Context3DProgramType;
+#elseif cpp
+typedef Context3DProgramType = native.display3D.Context3DProgramType;
+#end
\ No newline at end of file
diff --git a/nme/display3D/Context3DTextureFormat.hx b/nme/display3D/Context3DTextureFormat.hx
new file mode 100644
index 0000000..9a21342
--- /dev/null
+++ b/nme/display3D/Context3DTextureFormat.hx
@@ -0,0 +1,6 @@
+package nme.display3D;
+#if flash
+typedef Context3DTextureFormat = flash.display3D.Context3DTextureFormat;
+#else
+typedef Context3DTextureFormat = native.display3D.Context3DTextureFormat;
+#end
\ No newline at end of file
diff --git a/nme/display3D/Context3DTriangleFace.hx b/nme/display3D/Context3DTriangleFace.hx
new file mode 100644
index 0000000..6a570b5
--- /dev/null
+++ b/nme/display3D/Context3DTriangleFace.hx
@@ -0,0 +1,8 @@
+package nme.display3D;
+
+#if flash
+typedef Context3DTriangleFace = flash.display3D.Context3DTriangleFace;
+#elseif cpp
+typedef Context3DTriangleFace = native.display3D.Context3DTriangleFace;
+#end
+
diff --git a/nme/display3D/Context3DUtils.hx b/nme/display3D/Context3DUtils.hx
new file mode 100644
index 0000000..140a5ae
--- /dev/null
+++ b/nme/display3D/Context3DUtils.hx
@@ -0,0 +1,48 @@
+package nme.display3D;
+
+import nme.display3D.Context3DProgramType;
+import nme.display3D.Program3D;
+import nme.utils.ByteArray;
+import nme.display.BitmapData;
+import nme.display3D.textures.Texture;
+#if cpp
+import nme.gl.GL;
+#end
+
+class Context3DUtils {
+
+
+    inline public static function createShader(
+        #if flash
+        type : Context3DProgramType,
+        #elseif cpp
+        type : Int,
+        #end
+        shaderSource : String) :
+        #if flash
+            flash.utils.ByteArray
+        #elseif cpp
+            nme.gl.Shader
+        #end
+        {
+        #if flash
+        var assembler = new com.adobe.utils.AGALMiniAssembler();
+	    assembler.assemble(type, shaderSource);
+	    return assembler.agalcode();
+        #elseif cpp
+        var shader = GL.createShader(type);
+        GL.shaderSource(shader, shaderSource);
+        GL.compileShader(shader);
+        if (GL.getShaderParameter(shader, GL.COMPILE_STATUS)==0)
+        {
+            trace("--- ERR ---\n" + shaderSource);
+            var err = GL.getShaderInfoLog(shader);
+            if (err!="")
+                throw err;
+        }
+        return shader;
+        #end
+    }
+
+
+}
\ No newline at end of file
diff --git a/nme/display3D/Context3DVertexBufferFormat.hx b/nme/display3D/Context3DVertexBufferFormat.hx
new file mode 100644
index 0000000..d04eb74
--- /dev/null
+++ b/nme/display3D/Context3DVertexBufferFormat.hx
@@ -0,0 +1,6 @@
+package nme.display3D;
+#if flash
+typedef Context3DVertexBufferFormat = flash.display3D.Context3DVertexBufferFormat;
+#else
+typedef Context3DVertexBufferFormat = native.display3D.Context3DVertexBufferFormat;
+#end
diff --git a/nme/display3D/IndexBuffer3D.hx b/nme/display3D/IndexBuffer3D.hx
new file mode 100644
index 0000000..82dda42
--- /dev/null
+++ b/nme/display3D/IndexBuffer3D.hx
@@ -0,0 +1,7 @@
+package nme.display3D;
+
+#if flash
+typedef IndexBuffer3D = flash.display3D.IndexBuffer3D;
+#elseif cpp
+typedef IndexBuffer3D = native.display3D.IndexBuffer3D;
+#end
diff --git a/nme/display3D/Program3D.hx b/nme/display3D/Program3D.hx
new file mode 100644
index 0000000..440a5f2
--- /dev/null
+++ b/nme/display3D/Program3D.hx
@@ -0,0 +1,7 @@
+package nme.display3D;
+
+#if flash
+typedef Program3D = flash.display3D.Program3D;
+#elseif cpp
+typedef Program3D = native.display3D.Program3D;
+#end
\ No newline at end of file
diff --git a/nme/display3D/VertexBuffer3D.hx b/nme/display3D/VertexBuffer3D.hx
new file mode 100644
index 0000000..5d4e756
--- /dev/null
+++ b/nme/display3D/VertexBuffer3D.hx
@@ -0,0 +1,7 @@
+package nme.display3D;
+
+#if flash
+typedef VertexBuffer3D = flash.display3D.VertexBuffer3D;
+#elseif cpp
+typedef VertexBuffer3D = native.display3D.VertexBuffer3D;
+#end
\ No newline at end of file
diff --git a/nme/display3D/textures/Texture.hx b/nme/display3D/textures/Texture.hx
new file mode 100644
index 0000000..105d87d
--- /dev/null
+++ b/nme/display3D/textures/Texture.hx
@@ -0,0 +1,7 @@
+package nme.display3D.textures;
+
+#if flash
+typedef Texture = flash.display3D.textures.Texture;
+#elseif cpp
+typedef Texture = native.display3D.textures.Texture;
+#end
\ No newline at end of file
-- 
1.7.9.5

